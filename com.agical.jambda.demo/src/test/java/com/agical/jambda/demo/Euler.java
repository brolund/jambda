package com.agical.jambda.demo;

import static com.agical.jambda.Numeric.Integers.equals;
import static com.agical.jambda.Numeric.Integers.greaterThan;
import static com.agical.jambda.Numeric.Integers.modulo;
import static com.agical.jambda.Numeric.Integers.plus;
import static com.agical.jambda.Numeric.Integers.smallerThan;
import static com.agical.jambda.Numeric.Integers.sum;
import static com.agical.jambda.Sequence.filter;
import static com.agical.jambda.Sequence.foldLeft;
import static com.agical.jambda.Sequence.map;
import static com.agical.jambda.Sequence.range;
import static com.agical.jambda.Sequence.takeWhile;
import static com.agical.jambda.Tuples.duo;
import static org.junit.Assert.assertEquals;

import org.junit.Test;

import com.agical.jambda.Functions.Fn1;
import com.agical.jambda.Tuples.Tuple2;

public class Euler {
    /*!!
    Project Euler in jambda.
    */
    
    @Test
    public void eulerProblem1() throws Exception {
        /*!
        The problem:
        If we list all the natural numbers below 10 that are multiples 
        of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

        Find the sum of all the multiples of 3 or 5 below 1000.
        
        A solution in F#:
        >>>>
        List.fold_left (+) 0 (List.filter (fun n -> (n%3 = 0) || (n%5 = 0)) [0 .. 999])        
        <<<<
        
        In jambda it could be solved like this:
        */
        
        Integer sum = foldLeft( 
                filter(takeWhile(range(plus.apply(1), 0), smallerThan.rightCurry(1000)), 
                        new Fn1<Integer, Boolean>() {
                            public Boolean apply(Integer x) {
                                return x % 5 == 0 || x % 3 == 0;
                            }
                        }),
                plus,
                0);
        
        assertEquals(new Integer(233168), sum);
        /*!*/
    }
    
    @Test
    public void eulerProblem2() throws Exception {
        /*!
        The problem:
        Each new term in the Fibonacci sequence is generated by adding the previous 
        two terms. By starting with 1 and 2, the first 10 terms will be:

            1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

        Find the sum of all the even-valued terms in the sequence which do not exceed four million.
        
        A sollution in Haskell:
        >>>>
        module P2 where
            problem2:: Int -> Int
            problem2 y =    sum [ x | x <- takeWhile (<= y) fibonacci, mod x 2 ==0]
                where
                fibonacci = 0 : 1 : zipWith (+) fibonacci (tail fibonacci)
        <<<<
        In jambda it could be solved like this:
        */
        Iterable<Integer> fibs = map(range(
                new Fn1<Tuple2<Integer, Integer>, Tuple2<Integer, Integer>>() {
                    public Tuple2<Integer, Integer> apply(Tuple2<Integer, Integer> in) {
                        return duo(in.getSecond(), in.getFirst() + in.getSecond());
                    }
                },
                duo(0, 1)),
                Tuple2.<Integer, Integer>firstGetter());
        
        Integer sum = 
            sum(filter(takeWhile(fibs, greaterThan.apply(4000000)), 
                       modulo.rightCurry(2).compose(equals.apply(0))));
        
        assertEquals(new Integer(4613732), sum);
        /*!*/
    }
}

